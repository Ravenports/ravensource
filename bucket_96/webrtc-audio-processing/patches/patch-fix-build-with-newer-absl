From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Reilly Brogan <reilly@reillybrogan.com>
Date: Tue, 19 Aug 2025 14:47:03 -0500
Subject: [PATCH] Fix build with abseil-cpp 202508

---
 webrtc/api/audio/audio_processing.h           | 12 +++++++++
 webrtc/api/make_ref_counted.h                 | 13 ++++++++++
 webrtc/api/scoped_refptr.h                    | 15 +++++++++++
 .../aec_dump/aec_dump_factory.h               | 15 +++++++++++
 .../aec_dump/null_aec_dump_factory.cc         | 25 +++++++++++++++++++
 .../audio_processing/audio_processing_impl.cc |  9 +++++++
 .../audio_processing/audio_processing_impl.h  |  9 +++++++
 7 files changed, 98 insertions(+)

--- webrtc/api/audio/audio_processing.h.orig
+++ webrtc/api/audio/audio_processing.h
@@ -28,6 +28,7 @@
 #include <string>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/string_view.h"
 #include "api/array_view.h"
@@ -632,14 +633,25 @@ class RTC_EXPORT AudioProcessing : public RefCountInterface {
   // return value of true indicates that the file has been
   // sucessfully opened, while a value of false indicates that
   // opening the file failed.
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   virtual bool CreateAndAttachAecDump(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue) = 0;
   virtual bool CreateAndAttachAecDump(
       absl::Nonnull<FILE*> handle,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue) = 0;
+#else
+  virtual bool CreateAndAttachAecDump(absl::string_view file_name,
+                                      int64_t max_log_size_bytes,
+                                      TaskQueueBase* absl_nonnull
+                                          worker_queue) = 0;
+  virtual bool CreateAndAttachAecDump(FILE* absl_nonnull handle,
+                                      int64_t max_log_size_bytes,
+                                      TaskQueueBase* absl_nonnull
+                                          worker_queue) = 0;
+#endif
 
   // TODO(webrtc:5298) Deprecated variant.
   // Attaches provided webrtc::AecDump for recording debugging
--- webrtc/api/make_ref_counted.h
+++ webrtc/api/make_ref_counted.h
@@ -13,6 +13,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "api/ref_count.h"
 #include "api/scoped_refptr.h"
@@ -86,34 +87,46 @@ template <
     typename std::enable_if<std::is_convertible_v<T*, RefCountInterface*> &&
                                 std::is_abstract_v<T>,
                             T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<T>> make_ref_counted(Args&&... args) {
+#else
+absl_nonnull scoped_refptr<T> make_ref_counted(Args&&... args) {
+#endif
   return scoped_refptr<T>(new RefCountedObject<T>(std::forward<Args>(args)...));
 }
 
 // `make_ref_counted` for complete classes that are not convertible to
 // RefCountInterface and already carry a ref count.
 template <
     typename T,
     typename... Args,
     typename std::enable_if<
         !std::is_convertible_v<T*, RefCountInterface*> &&
             webrtc_make_ref_counted_internal::HasAddRefAndRelease<T>::value,
         T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<T>> make_ref_counted(Args&&... args) {
+#else
+absl_nonnull scoped_refptr<T> make_ref_counted(Args&&... args) {
+#endif
   return scoped_refptr<T>(new T(std::forward<Args>(args)...));
 }
 
 // `make_ref_counted` for complete classes that are not convertible to
 // RefCountInterface and have no ref count of their own.
 template <
     typename T,
     typename... Args,
     typename std::enable_if<
         !std::is_convertible_v<T*, RefCountInterface*> &&
             !webrtc_make_ref_counted_internal::HasAddRefAndRelease<T>::value,
 
         T>::type* = nullptr>
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nonnull<scoped_refptr<FinalRefCountedObject<T>>> make_ref_counted(
+#else
+absl_nonnull scoped_refptr<FinalRefCountedObject<T>> make_ref_counted(
+#endif
     Args&&... args) {
   return scoped_refptr<FinalRefCountedObject<T>>(
       new FinalRefCountedObject<T>(std::forward<Args>(args)...));
--- webrtc/api/scoped_refptr.h.orig
+++ webrtc/api/scoped_refptr.h
@@ -66,20 +66,27 @@
 #include <cstddef>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 
 namespace webrtc {
 
 template <class T>
 class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
  public:
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   using absl_nullability_compatible = void;
+#endif
   using element_type = T;
 
   scoped_refptr() : ptr_(nullptr) {}
   scoped_refptr(std::nullptr_t) : ptr_(nullptr) {}  // NOLINT(runtime/explicit)
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   explicit scoped_refptr(absl::Nullable<T*> p) : ptr_(p) {
+#else
+  explicit scoped_refptr(T* absl_nullable p) : ptr_(p) {
+#endif
     if (ptr_)
       ptr_->AddRef();
   }
@@ -122,7 +129,11 @@ class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
     return retVal;
   }
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   scoped_refptr<T>& operator=(absl::Nullable<T*> p) {
+#else
+  scoped_refptr<T>& operator=(T* absl_nullable p) {
+#endif
     // AddRef first so that self assignment should work
     if (p)
       p->AddRef();
@@ -152,7 +163,11 @@ class ABSL_NULLABILITY_COMPATIBLE scoped_refptr {
     return *this;
   }
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   void swap(absl::Nonnull<T**> pp) noexcept {
+#else
+  void swap(T** absl_nonnull pp) noexcept {
+#endif
     T* p = ptr_;
     ptr_ = *pp;
     *pp = p;
--- webrtc/modules/audio_processing/aec_dump/aec_dump_factory.h.orig
+++ webrtc/modules/audio_processing/aec_dump/aec_dump_factory.h
@@ -29,18 +29,33 @@ class RTC_EXPORT AecDumpFactory {
   // The AecDump takes responsibility for `handle` and closes it in the
   // destructor. A non-null return value indicates that the file has been
   // sucessfully opened.
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       FileWrapper file,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
   static absl::Nullable<std::unique_ptr<AecDump>> Create(
       absl::Nonnull<FILE*> handle,
       int64_t max_log_size_bytes,
       absl::Nonnull<TaskQueueBase*> worker_queue);
+#else
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      FileWrapper file,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      absl::string_view file_name,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+  static absl_nullable std::unique_ptr<AecDump> Create(
+      FILE* absl_nonnull handle,
+      int64_t max_log_size_bytes,
+      TaskQueueBase* absl_nonnull worker_queue);
+#endif
 };
 
 }  // namespace webrtc
--- webrtc/modules/audio_processing/aec_dump/null_aec_dump_factory.cc.orig
+++ webrtc/modules/audio_processing/aec_dump/null_aec_dump_factory.cc
@@ -16,24 +16,49 @@
 
 namespace webrtc {
 
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     FileWrapper file,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     absl::string_view file_name,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 
 absl::Nullable<std::unique_ptr<AecDump>> AecDumpFactory::Create(
     absl::Nonnull<FILE*> handle,
     int64_t max_log_size_bytes,
     absl::Nonnull<TaskQueueBase*> worker_queue) {
   return nullptr;
 }
 }  // namespace webrtc
+#else
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    FileWrapper file,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    absl::string_view file_name,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+
+absl_nullable std::unique_ptr<AecDump> AecDumpFactory::Create(
+    FILE* absl_nonnull handle,
+    int64_t max_log_size_bytes,
+    TaskQueueBase* absl_nonnull worker_queue) {
+  return nullptr;
+}
+}  // namespace webrtc
+
+#endif
--- webrtc/modules/audio_processing/audio_processing_impl.cc.orig
+++ webrtc/modules/audio_processing/audio_processing_impl.cc
@@ -19,6 +19,7 @@
 #include <type_traits>
 #include <utility>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/match.h"
 #include "absl/strings/string_view.h"
@@ -1787,21 +1788,29 @@ void AudioProcessingImpl::UpdateRecommendedInputVolumeLocked() {
 bool AudioProcessingImpl::CreateAndAttachAecDump(
     absl::string_view file_name,
     int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
     absl::Nonnull<TaskQueueBase*> worker_queue) {
+#else
+    TaskQueueBase* absl_nonnull worker_queue) {
+#endif
   std::unique_ptr<AecDump> aec_dump =
       AecDumpFactory::Create(file_name, max_log_size_bytes, worker_queue);
   if (!aec_dump) {
     return false;
   }
 
   AttachAecDump(std::move(aec_dump));
   return true;
 }
 
 bool AudioProcessingImpl::CreateAndAttachAecDump(
     FILE* handle,
     int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
     absl::Nonnull<TaskQueueBase*> worker_queue) {
+#else
+    TaskQueueBase* absl_nonnull worker_queue) {
+#endif
   std::unique_ptr<AecDump> aec_dump =
       AecDumpFactory::Create(handle, max_log_size_bytes, worker_queue);
   if (!aec_dump) {
--- webrtc/modules/audio_processing/audio_processing_impl.h.orig
+++ webrtc/modules/audio_processing/audio_processing_impl.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include "absl/base/config.h"
 #include "absl/base/nullability.h"
 #include "absl/strings/string_view.h"
 #include "api/array_view.h"
@@ -74,11 +75,19 @@ class AudioProcessingImpl : public AudioProcessing {
   bool CreateAndAttachAecDump(
       absl::string_view file_name,
       int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
       absl::Nonnull<TaskQueueBase*> worker_queue) override;
+#else
+      TaskQueueBase* absl_nonnull worker_queue) override;
+#endif
   bool CreateAndAttachAecDump(
       FILE* handle,
       int64_t max_log_size_bytes,
+#if defined(ABSL_LTS_RELEASE_VERSION) && ABSL_LTS_RELEASE_VERSION < 20250512
       absl::Nonnull<TaskQueueBase*> worker_queue) override;
+#else
+      TaskQueueBase* absl_nonnull worker_queue) override;
+#endif
   // TODO(webrtc:5298) Deprecated variant.
   void AttachAecDump(std::unique_ptr<AecDump> aec_dump) override;
   void DetachAecDump() override;
