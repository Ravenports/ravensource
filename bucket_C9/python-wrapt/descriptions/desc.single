# wrapt

[PyPI]
[Documentation]
[License]

A Python module for decorators, wrappers and monkey patching.

## Overview

The **wrapt** module provides a transparent object proxy for Python, which
can be used as the basis for the construction of function wrappers and
decorator functions.

The **wrapt** module focuses very much on correctness. It goes way beyond
existing mechanisms such as `functools.wraps()` to ensure that decorators
preserve introspectability, signatures, type checking abilities etc. The
decorators that can be constructed using this module will work in far more
scenarios than typical decorators and provide more predictable and
consistent behaviour.

To ensure that the overhead is as minimal as possible, a C extension module
is used for performance critical components. An automatic fallback to a
pure Python implementation is also provided where a target system does not
have a compiler to allow the C extension to be compiled.

## Features

- **Universal decorators** that work with functions, methods, classmethods,
staticmethods, and classes
- **Transparent object proxies** for advanced wrapping scenarios
- **Monkey patching utilities** for safe runtime modifications
- **C extension** for optimal performance with Python fallback
- **Comprehensive introspection preservation** (signatures, annotations,
etc.)
- **Thread-safe decorator implementations**

## Installation

`bash
pip install wrapt
`

## Quick Start

### Basic Decorator

```python
import wrapt

@wrapt.decorator
def pass_through(wrapped, instance, args, kwargs):
    return wrapped(*args, **kwargs)

@pass_through
def function():
    pass
```

### Decorator with Arguments

```python
import wrapt

def with_arguments(myarg1, myarg2):
    @wrapt.decorator
    def wrapper(wrapped, instance, args, kwargs):
        print(f"Arguments: {myarg1}, {myarg2}")
        return wrapped(*args, **kwargs)
    return wrapper

@with_arguments(1, 2)
def function():
    pass
```

### Universal Decorator

```python
import inspect
import wrapt

@wrapt.decorator
def universal(wrapped, instance, args, kwargs):
    if instance is None:
        if inspect.isclass(wrapped):
            # Decorator was applied to a class
            print("Decorating a class")
        else:
            # Decorator was applied to a function or staticmethod
            print("Decorating a function")
    else:
        if inspect.isclass(instance):
            # Decorator was applied to a classmethod
            print("Decorating a classmethod")
        else:
            # Decorator was applied to an instancemethod
            print("Decorating an instance method")
    
    return wrapped(*args, **kwargs)
